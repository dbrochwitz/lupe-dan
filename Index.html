<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>9:16 Kompositionstool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #ececec;
      font-family: system-ui, sans-serif;
      min-height: 100vh;
    }
    .container {
      max-width: 800px;
      margin: 0 auto 2em auto;
      background: #fff;
      box-shadow: 0 8px 32px rgba(0,0,0,0.10);
      border-radius: 24px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      text-align: center;
      font-size: 1.5em;
      margin-bottom: 0.75em;
      margin-top: 0.5em;
    }
    .controls {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1em;
    }
    .upload-controls {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
    }
    .upload-controls label {
      display: block;
      font-weight: 500;
      margin-bottom: 4px;
    }
    .upload-controls input[type="file"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    .circle-controls {
      margin-bottom: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      align-items: center;
    }
    .circle-group {
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .circle-group span {
      font-weight:500;
      margin-right:6px;
      min-width: 100%;
      text-align: center;
      margin-bottom: 4px;
    }
    .circle-group input[type="range"] {
      min-width: 48px;
      min-height: 48px;
      font-size: 0.9em;
      border-radius: 8px;
      margin: 2px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      color: #333;
      cursor: pointer;
      outline: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.03);
    }
    input[type="range"] {
      width: 200px;
    }
    .main-actions {
      margin: 15px 0 15px 0;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .main-actions button {
      min-width: 100px;
      min-height: 48px;
      font-size: 1.09em;
      border-radius: 8px;
      margin: 5px 3px;
      padding: 7px 20px;
      font-weight: bold;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.09);
      transition: background 0.2s;
    }
    .main-actions .primary { background: #3bc654; color: #fff;}
    .main-actions .secondary { background: #3687eb; color: #fff;}
    #canvasContainer {
      width: 100%;
      max-width: 400px;
      border: 2px solid #bbb;
      border-radius: 0;
      box-shadow: 0 4px 24px rgba(0,0,0,0.14);
      background: #eee;
      position: relative;
      overflow: hidden;
      display: flex;
      margin-left: auto;
      margin-right: auto;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 0;
      touch-action: none;
      user-select: none;
      background: #f5f5f5;
    }
    @media (max-width: 540px) {
      .container {
        border-radius: 0;
        padding: 12px;
      }
      #canvasContainer {
        max-width: 95vw;
        border-radius: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>9:16 Komposition erstellen</h1>
    
    <div class="controls">
      <div class="upload-controls">
        <label>
          Hintergrundbild:
          <input type="file" id="backgroundUpload" accept="image/*" />
        </label>
        <label>
          Overlay-Bild:
          <input type="file" id="overlayUpload" accept="image/*" />
        </label>
      </div>
      <div class="circle-controls">
        <div class="circle-group" id="lowerCircleControls">
          <span>Unterer Kreis Größe:</span>
          <input type="range" id="lowerCircleRadius" min="30" max="500" value="120"/>
        </div>
        <div class="circle-group" id="upperCircleControls">
          <span>Overlay-Kreis Bild-Zoom:</span>
          <input type="range" id="upperCircleZoom" min="100" max="450" value="150" step="1"/>
        </div>
        <div class="circle-group" id="upperCircleSizeControls">
          <span>Overlay-Kreis Größe:</span>
          <input type="range" id="upperCircleRadius" min="30" max="500" value="400"/>
        </div>
      </div>
      <div class="main-actions">
        <button id="resetBtn" class="secondary">Zurücksetzen</button>
        <button id="downloadBtn" class="primary">Download PNG</button>
      </div>
    </div>
    
    <div id="canvasContainer">
      <canvas id="compositionCanvas"></canvas>
    </div>
  </div>
  <script>
/* Canvas Setup */
const canvas = document.getElementById('compositionCanvas');
const ctx = canvas.getContext('2d');

// Canvas auf feste Größe setzen
canvas.width = 1080;
canvas.height = 1920;

/* Hilfsfunktionen */
function clamp(val, min, max) { 
  return Math.max(min, Math.min(max, val)); 
}

/* State - Startwerte aus Slidern */
let state = {
  bgImg: null,
  overlayImg: null,
  upper: {
    x: 540, 
    y: 700, 
    radius: 400,  // Startwert entspricht Slider-Position 400
    imgOffsetX: 0, 
    imgOffsetY: 0, 
    zoom: 1.5,    // Startwert entspricht Slider-Position 150 (150/100 = 1.5)
    minZoom: 1.0, 
    maxZoom: 4.5
  },
  lower: {
    x: 540, 
    y: 1400, 
    radius: 120
  }
};

/* Interaktionsmodus - wird dynamisch erkannt */
let interactionMode = 'move'; // 'move', 'pan', oder 'zoom'

/* Default-Bilder laden beim Start */
function loadDefaultImages() {
  // Hintergrundbild laden
  let bgImg = new Image();
  bgImg.onload = () => {
    state.bgImg = bgImg;
    draw();
  };
  bgImg.onerror = () => {
    console.log('Hintergrundbild default.jpg nicht gefunden');
    draw();
  };
  bgImg.src = 'default.jpg';
  
  // Overlay-Bild laden
  let overlayImg = new Image();
  overlayImg.onload = () => {
    state.overlayImg = overlayImg;
    draw();
  };
  overlayImg.onerror = () => {
    console.log('Overlay-Bild default.jpg nicht gefunden');
    draw();
  };
  overlayImg.src = 'default.jpg';
}

// Default-Bilder beim Laden der Seite laden
loadDefaultImages();

/* File-Handling */
document.getElementById('backgroundUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    let img = new Image();
    img.onload = () => {
      state.bgImg = img;
      draw();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('overlayUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    let img = new Image();
    img.onload = () => {
      state.overlayImg = img;
      draw();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

/* UI-Controls */
// Schieberegler für oberen Kreis Bild-Zoom (100-450%)
document.getElementById('upperCircleZoom').addEventListener('input',e=>{
  state.upper.zoom = Number(e.target.value) / 100;
  draw();
});

// Schieberegler für oberen Kreis Größe
document.getElementById('upperCircleRadius').addEventListener('input',e=>{
  state.upper.radius = Number(e.target.value);
  draw();
});

// Schieberegler für unteren Kreis Größe
document.getElementById('lowerCircleRadius').addEventListener('input',e=>{
  state.lower.radius = Number(e.target.value);
  draw();
});

/* Reset */
document.getElementById('resetBtn').addEventListener('click',()=>{
  state.upper = { 
    x:540, y:700, radius:400,
    imgOffsetX:0, imgOffsetY:0, zoom:1.5, 
    minZoom:1.0, maxZoom:4.5 
  };
  state.lower = { x:540, y:1400, radius:120 };
  document.getElementById('upperCircleZoom').value = 150;
  document.getElementById('upperCircleRadius').value = 400;
  document.getElementById('lowerCircleRadius').value = 120;
  draw();
});

/* Download PNG */
document.getElementById('downloadBtn').addEventListener('click',()=>{
  let url = canvas.toDataURL("image/png");
  let a = document.createElement('a');
  a.href = url;
  a.download = '9-16-komposition.png';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>document.body.removeChild(a),200);
});

/* Drag & Interaction */
let activeCircle = null;
let dragStart = null;
let panStart = null;
let zoomDistStart = 0;
let zoomValStart = 1;
let radiusStart = 0;
let lastTouches = [];

function getCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

function distance(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function insideCircle(pos, circle) {
  return distance(pos, circle) < circle.radius;
}

function getTouchCenter(t1, t2) {
  return {
    x: (t1.x + t2.x) / 2,
    y: (t1.y + t2.y) / 2
  };
}

/* Mouse & Touch Events */
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

canvas.addEventListener('touchstart', handleStart, {passive: false});
canvas.addEventListener('touchmove', handleMove, {passive: false});
canvas.addEventListener('touchend', handleEnd, {passive: false});

function handleStart(e) {
  e.preventDefault();
  
  let pos;
  if (e.touches && e.touches.length === 1) {
    pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    // Ein-Finger-Touch: Kreis verschieben (nicht Bild!)
    if (insideCircle(pos, state.upper)) {
      activeCircle = 'upper';
      dragStart = pos;
      panStart = { ...state.upper };
      interactionMode = 'move'; // Kreis verschieben
    } else if (insideCircle(pos, state.lower)) {
      activeCircle = 'lower';
      dragStart = pos;
      panStart = { ...state.lower };
      interactionMode = 'move';
    }
  } else if (e.touches && e.touches.length === 2) {
    // Zwei-Finger-Geste
    const t1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    const t2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
    const center = getTouchCenter(t1, t2);
    
    // Prüfe, welcher Kreis betroffen ist
    if (insideCircle(center, state.upper)) {
      activeCircle = 'upper';
      lastTouches = [t1, t2];
      zoomDistStart = distance(t1, t2);
      zoomValStart = state.upper.zoom;
      interactionMode = 'zoom'; // Bild zoomen
    } else if (insideCircle(center, state.lower)) {
      activeCircle = 'lower';
      lastTouches = [t1, t2];
      zoomDistStart = distance(t1, t2);
      radiusStart = state.lower.radius;
      interactionMode = 'resize';
    }
    return;
  } else if (e.clientX !== undefined) {
    // Maus: Kreis verschieben
    pos = getCanvasCoords(e.clientX, e.clientY);
    if (insideCircle(pos, state.upper)) {
      activeCircle = 'upper';
      dragStart = pos;
      panStart = { ...state.upper };
      interactionMode = 'move';
    } else if (insideCircle(pos, state.lower)) {
      activeCircle = 'lower';
      dragStart = pos;
      panStart = { ...state.lower };
      interactionMode = 'move';
    }
  }
}

function handleMove(e) {
  e.preventDefault();
  
  if (!activeCircle) return;
  
  // Handle zwei-Finger Pinch
  if (e.touches && e.touches.length === 2 && lastTouches.length === 2) {
    const t1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    const t2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
    
    const lastDist = distance(lastTouches[0], lastTouches[1]);
    const nowDist = distance(t1, t2);
    const scale = nowDist / lastDist;
    
    if (activeCircle === 'upper' && interactionMode === 'zoom') {
      // Zoom für Bildinhalt
      state.upper.zoom = clamp(state.upper.zoom * scale, state.upper.minZoom, state.upper.maxZoom);
      document.getElementById('upperCircleZoom').value = state.upper.zoom * 100;
    } else if (activeCircle === 'lower' && interactionMode === 'resize') {
      // Kreisgröße für unteren Kreis
      state.lower.radius = clamp(state.lower.radius * scale, 30, 500);
      document.getElementById('lowerCircleRadius').value = state.lower.radius;
    }
    
    lastTouches = [t1, t2];
    draw();
    return;
  }
  
  if (!dragStart) return;
  
  let pos;
  if (e.touches && e.touches.length === 1) {
    pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
  } else if (e.clientX !== undefined) {
    pos = getCanvasCoords(e.clientX, e.clientY);
  }
  
  if (!pos) return;
  
  if (activeCircle === 'upper') {
    if (interactionMode === 'move') {
      // Kreis verschieben
      state.upper.x = clamp(panStart.x + (pos.x - dragStart.x), state.upper.radius, canvas.width - state.upper.radius);
      state.upper.y = clamp(panStart.y + (pos.y - dragStart.y), state.upper.radius, canvas.height - state.upper.radius);
    } else if (interactionMode === 'pan') {
      // Bildausschnitt verschieben (wird jetzt nicht mehr über Touch aktiviert)
      state.upper.imgOffsetX = panStart.imgOffsetX + (pos.x - dragStart.x);
      state.upper.imgOffsetY = panStart.imgOffsetY + (pos.y - dragStart.y);
    }
  } else if (activeCircle === 'lower') {
    // Kreis verschieben
    state.lower.x = clamp(panStart.x + (pos.x - dragStart.x), state.lower.radius, canvas.width - state.lower.radius);
    state.lower.y = clamp(panStart.y + (pos.y - dragStart.y), state.lower.radius, canvas.height - state.lower.radius);
  }
  
  draw();
}

function handleEnd(e) {
  e.preventDefault();
  activeCircle = null;
  dragStart = null;
  panStart = null;
  lastTouches = [];
  interactionMode = 'move';
}

/* Drawing */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Hintergrund - ohne Abrundung
  if (state.bgImg) {
    ctx.drawImage(state.bgImg, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = "#e0e0e8";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  
  // Verbindungslinie (nur außerhalb der Kreise)
  const dist = distance(state.upper, state.lower);
  if (dist > state.upper.radius + state.lower.radius) {
    // Berechne Startpunkt (am Rand des oberen Kreises)
    const angle = Math.atan2(state.lower.y - state.upper.y, state.lower.x - state.upper.x);
    const startX = state.upper.x + Math.cos(angle) * state.upper.radius;
    const startY = state.upper.y + Math.sin(angle) * state.upper.radius;
    
    // Berechne Endpunkt (am Rand des unteren Kreises)
    const endX = state.lower.x - Math.cos(angle) * state.lower.radius;
    const endY = state.lower.y - Math.sin(angle) * state.lower.radius;
    
    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.4)";
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 5;
    ctx.shadowOffsetY = 5;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.restore();
  }
  
  // Unterer Kreis - nur Outline (durchsichtig)
  drawCircleOutline(state.lower.x, state.lower.y, state.lower.radius);
  
  // Oberer Kreis - zuerst weiße Füllung, dann Bild mit Clip, dann Outline
  drawCircleFilled(state.upper.x, state.upper.y, state.upper.radius, "#ffffff");
  
  if (state.overlayImg) {
    ctx.save();
    
    // Clip für Kreis (etwas kleiner als Radius für Outline-Platz)
    ctx.beginPath();
    ctx.arc(state.upper.x, state.upper.y, state.upper.radius - 4, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    
    // Cover-Modus: Bild füllt den Kreis IMMER vollständig ohne Verzerrung
    const imgAspect = state.overlayImg.width / state.overlayImg.height;
    const circleSize = (state.upper.radius - 4) * 2;
    
    let drawWidth, drawHeight;
    
    // Berechne Dimensionen so, dass der Kreis IMMER gefüllt ist
    if (imgAspect > 1) {
      // Querformat: Höhe muss mindestens Kreisdurchmesser sein
      drawHeight = circleSize * state.upper.zoom;
      drawWidth = drawHeight * imgAspect;
    } else {
      // Hochformat: Breite muss mindestens Kreisdurchmesser sein
      drawWidth = circleSize * state.upper.zoom;
      drawHeight = drawWidth / imgAspect;
    }
    
    // Sicherstellen, dass keine Dimension kleiner als Kreisdurchmesser ist
    const minSize = circleSize * state.upper.zoom;
    if (drawWidth < minSize) {
      drawWidth = minSize;
      drawHeight = drawWidth / imgAspect;
    }
    if (drawHeight < minSize) {
      drawHeight = minSize;
      drawWidth = drawHeight * imgAspect;
    }
    
    ctx.drawImage(
      state.overlayImg,
      state.upper.x - drawWidth/2 + state.upper.imgOffsetX,
      state.upper.y - drawHeight/2 + state.upper.imgOffsetY,
      drawWidth,
      drawHeight
    );
    
    ctx.restore();
  }
  
  // Outline für oberen Kreis (über das Bild)
  drawCircleOutline(state.upper.x, state.upper.y, state.upper.radius);
}

// Gefüllten Kreis zeichnen (ohne Schatten)
function drawCircleFilled(x, y, radius, fillColor) {
  ctx.save();
  ctx.fillStyle = fillColor;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// Nur Outline mit Schatten zeichnen
function drawCircleOutline(x, y, radius) {
  ctx.save();
  
  // Schatten nur für die Outline
  ctx.shadowColor = "rgba(0,0,0,0.4)";
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 5;
  ctx.shadowOffsetY = 5;
  
  // Weißer Rand
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.restore();
}

/* Initial Draw */
draw();
  </script>
</body>
</html>
