<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Responsiver 9:16 Bild-Editor mit Touch</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f5f5f5;
    margin: 0;
    padding: 20px;
    display: flex;
    justify-content: center;
  }
  .container {
    background: white;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 1080px;
    width: 100vw;
    box-sizing: border-box;
  }
  h1 {
    text-align: center;
    margin-top: 0;
  }
  canvas {
    display: block;
    margin: 20px auto;
    border: 2px solid #ddd;
    border-radius: 5px;
    width: 100%;
    height: auto; /* Höhe wird per JS gesetzt */
    touch-action: none; /* verhindert Scroll bei Touch-Gesten */
  }
  button {
    padding: 10px 20px;
    margin: 10px 5px;
    border:none;
    border-radius: 5px;
    background: #2196F3;
    color: white;
    cursor: pointer;
    min-width: 140px;
  }
  button.active {
    background: #4CAF50;
  }
  .buttons {
    text-align: center;
  }
  .upload-section {
    text-align: center;
    margin-bottom: 20px;
  }
  input[type=file] {
    margin-top: 10px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Responsiver Bild-Editor: Modus Umschalter</h1>

  <div class="upload-section">
    <label for="backgroundUpload">Hintergrundbild hochladen:</label><br/>
    <input type="file" id="backgroundUpload" accept="image/*" />
  </div>

  <div class="upload-section">
    <label for="overlayUpload">Bild für den ersten Kreis hochladen:</label><br/>
    <input type="file" id="overlayUpload" accept="image/*" />
  </div>

  <canvas id="canvas" width="1080" height="1920"></canvas>
  
  <div class="buttons">
    <button id="mode1" class="active">Modus 1: Kreis bewegen/skalieren</button>
    <button id="mode2">Modus 2: Bild bewegen/zoomen</button>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let mode = 1;
const maxWidth = 1080;
const aspectRatio = 9/16;

function resizeCanvas() {
  const containerWidth = Math.min(window.innerWidth - 40, maxWidth);
  canvas.style.width = containerWidth + 'px';
  canvas.style.height = (containerWidth / aspectRatio) + 'px';
  // Hohe Auflösung im Hintergrund beibehalten für schärfe
  canvas.width = maxWidth;
  canvas.height = maxWidth / aspectRatio;
  draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const backgroundImg = new Image();
const overlayImg = new Image();
backgroundImg.src = 'default.jpg';
overlayImg.src = 'default.jpg';

let overlay1 = {
  x: canvas.width/2, y: canvas.height*0.365,
  radius: 250,
  rotation: 0
};

let overlay2 = {
  x: canvas.width/2, y: canvas.height*0.678,
  radius: 250,
  rotation: 0
};

let imageTransform = { x: 0, y: 0, scale: 1 };

let dragging = false;
let dragStart = {x:0, y:0};
let dragMode = null;
let activeOverlay = null;
let dragStartImage = null;

overlayImg.onload = backgroundImg.onload = () => {
  overlay1.x = canvas.width/2;
  overlay1.y = canvas.height*0.365;
  overlay2.x = canvas.width/2;
  overlay2.y = canvas.height*0.678;
  draw();
};

document.getElementById('mode1').onclick = () => switchMode(1);
document.getElementById('mode2').onclick = () => switchMode(2);

function switchMode(m){
  mode = m;
  document.getElementById('mode1').classList.toggle('active', mode===1);
  document.getElementById('mode2').classList.toggle('active', mode===2);
}

function getPointerPos(e){
  const rect = canvas.getBoundingClientRect();
  if(e.touches){
    return {
      x: (e.touches[0].clientX - rect.left) * canvas.width / rect.width,
      y: (e.touches[0].clientY - rect.top) * canvas.height / rect.height,
    };
  } else {
    return {
      x: (e.clientX - rect.left) * canvas.width / rect.width,
      y: (e.clientY - rect.top) * canvas.height / rect.height,
    };
  }
}

function isInsideCircle(px, py, circle){
  const dx = px - circle.x;
  const dy = py - circle.y;
  return Math.sqrt(dx*dx + dy*dy) <= circle.radius;
}

function isOnCircleEdge(px, py, circle, edgeWidth=20){
  const dx = px - circle.x;
  const dy = py - circle.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  return dist >= circle.radius - edgeWidth && dist <= circle.radius + edgeWidth;
}

function startDrag(e){
  e.preventDefault();
  let pos = getPointerPos(e);
  if(mode === 1){
    if(isOnCircleEdge(pos.x,pos.y,overlay2)){
      activeOverlay = overlay2;
      dragMode = "scale";
    } else if(isOnCircleEdge(pos.x,pos.y,overlay1)){
      activeOverlay = overlay1;
      dragMode = "scale";
    } else if(isInsideCircle(pos.x, pos.y, overlay2)) {
      activeOverlay = overlay2;
      dragMode = "move";
    } else if(isInsideCircle(pos.x, pos.y, overlay1)) {
      activeOverlay = overlay1;
      dragMode = "move";
    } else {
      activeOverlay = null;
      dragMode = null;
      return;
    }
  } else if(mode === 2){
    if(isInsideCircle(pos.x, pos.y, overlay1)){
      activeOverlay = overlay1;
      dragMode = "moveImage";
      dragStartImage = {...imageTransform};
    } else {
      activeOverlay = null;
      dragMode = null;
      return;
    }
  }
  dragging = true;
  dragStart = pos;
}

canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('touchstart', e=>startDrag(e));

canvas.addEventListener('mousemove', e=>{
  if(!dragging || !activeOverlay) return;
  e.preventDefault();
  let pos = getPointerPos(e);
  let dx = pos.x - dragStart.x;
  let dy = pos.y - dragStart.y;
  dragStart = pos;

  if(mode === 1){
    if(dragMode === "move"){
      activeOverlay.x += dx;
      activeOverlay.y += dy;
    } else if(dragMode === "scale"){
      const distCenter = Math.sqrt(Math.pow(pos.x - activeOverlay.x,2) + Math.pow(pos.y - activeOverlay.y,2));
      activeOverlay.radius = Math.max(30, distCenter);
    }
  } else if(mode === 2 && dragMode === "moveImage"){
    imageTransform.x = dragStartImage.x + dx;
    imageTransform.y = dragStartImage.y + dy;
  }
  draw();
});

canvas.addEventListener('touchmove', e=>{
  if(!dragging || !activeOverlay) return;
  e.preventDefault();
  let pos = getPointerPos(e);
  let dx = pos.x - dragStart.x;
  let dy = pos.y - dragStart.y;
  dragStart = pos;

  if(mode === 1){
    if(dragMode === "move"){
      activeOverlay.x += dx;
      activeOverlay.y += dy;
    } else if(dragMode === "scale"){
      const distCenter = Math.sqrt(Math.pow(pos.x - activeOverlay.x,2) + Math.pow(pos.y - activeOverlay.y,2));
      activeOverlay.radius = Math.max(30, distCenter);
    }
  } else if(mode === 2 && dragMode === "moveImage"){
    imageTransform.x = dragStartImage.x + dx;
    imageTransform.y = dragStartImage.y + dy;
  }
  draw();
},{passive:false});

canvas.addEventListener('mouseup', stopDrag);
canvas.addEventListener('mouseleave', stopDrag);
canvas.addEventListener('touchend', stopDrag);
canvas.addEventListener('touchcancel', stopDrag);

function stopDrag(e){
  dragging = false;
  activeOverlay = null;
  dragMode = null;
}

canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  if(mode === 1){
    if(activeOverlay){
      const delta = e.deltaY > 0 ? 0.95 : 1.05;
      activeOverlay.radius = Math.max(30, activeOverlay.radius * delta);
      draw();
    }
  } else if(mode === 2){
    const delta = e.deltaY > 0 ? 0.95 : 1.05;
    imageTransform.scale *= delta;
    draw();
  }
},{passive:false});

document.getElementById('backgroundUpload').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    backgroundImg.src = evt.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('overlayUpload').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    overlayImg.src = evt.target.result;
    imageTransform = { x: 0, y: 0, scale: 1 };
  };
  reader.readAsDataURL(file);
});

function drawBackground(){
  if(!backgroundImg.complete) return;  
  const canvasRatio = canvas.width / canvas.height;
  const imgRatio = backgroundImg.width / backgroundImg.height;
  let w, h, x, y;
  if(imgRatio > canvasRatio){
    h = canvas.height;
    w = h * imgRatio;
    x = (canvas.width - w) / 2;
    y = 0;
  } else {
    w = canvas.width;
    h = w / imgRatio;
    x = 0;
    y = (canvas.height - h) / 2;
  }
  ctx.drawImage(backgroundImg, x, y, w, h);
}

function drawOverlay1(){
  if(!overlayImg.complete) return;
  ctx.save();

  ctx.beginPath();
  ctx.arc(overlay1.x, overlay1.y, overlay1.radius, 0, Math.PI*2);
  ctx.closePath();
  ctx.clip();

  const imgRatio = overlayImg.width / overlayImg.height;
  const circleDiameter = overlay1.radius * 2;
  let scaledWidth, scaledHeight;
  if(imgRatio > 1){
    scaledHeight = circleDiameter;
    scaledWidth = scaledHeight * imgRatio;
  } else {
    scaledWidth = circleDiameter;
    scaledHeight = scaledWidth / imgRatio;
  }

  const imgX = overlay1.x - scaledWidth / 2 + imageTransform.x;
  const imgY = overlay1.y - scaledHeight / 2 + imageTransform.y;

  ctx.drawImage(overlayImg, imgX, imgY, scaledWidth*imageTransform.scale, scaledHeight*imageTransform.scale);
  ctx.restore();

  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.5)";
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 8;
  ctx.shadowOffsetY = 8;
  ctx.beginPath();
  ctx.arc(overlay1.x, overlay1.y, overlay1.radius, 0, Math.PI*2);
  ctx.strokeStyle = "#FFFFFF";
  ctx.lineWidth = 8;
  ctx.stroke();
  ctx.restore();
}

function drawOverlay2(){
  ctx.save();
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 8;
  ctx.shadowOffsetY = 8;

  ctx.beginPath();
  ctx.arc(overlay2.x, overlay2.y, overlay2.radius, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fill();
  ctx.lineWidth = 8;
  ctx.strokeStyle = '#FFFFFF';
  ctx.stroke();

  ctx.restore();
}

function drawConnectionLine(){
  const dx = overlay2.x - overlay1.x;
  const dy = overlay2.y - overlay1.y;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if(dist <= overlay1.radius + overlay2.radius) return;

  const angle = Math.atan2(dy, dx);

  const startX = overlay1.x + Math.cos(angle)*overlay1.radius;
  const startY = overlay1.y + Math.sin(angle)*overlay1.radius;

  const endX = overlay2.x - Math.cos(angle)*overlay2.radius;
  const endY = overlay2.y - Math.sin(angle)*overlay2.radius;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(endX, endY);
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 8;
  ctx.stroke();
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBackground();
  drawConnectionLine();
  drawOverlay1();
  drawOverlay2();
}
</script>
</body>
</html>
