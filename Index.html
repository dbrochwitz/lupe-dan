<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>9:16 Kompositionstool v02</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #ececec;
      font-family: system-ui, sans-serif;
      min-height: 100vh;
    }
    .container {
      max-width: 800px;
      margin: 0 auto 2em auto;
      background: #fff;
      box-shadow: 0 8px 32px rgba(0,0,0,0.10);
      border-radius: 24px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      text-align: center;
      font-size: 1.5em;
      margin-bottom: 0.75em;
      margin-top: 0.5em;
    }
    .controls {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1em;
    }
    .upload-controls {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
    }
    .upload-controls label {
      display: block;
      font-weight: 500;
      margin-bottom: 4px;
    }
    .upload-controls input[type="file"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    .circle-controls {
      margin-bottom: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      align-items: center;
    }
    .circle-group {
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .circle-group span {
      font-weight:500;
      margin-right:6px;
      min-width: 100%;
      text-align: center;
      margin-bottom: 4px;
    }
    .circle-group input[type="range"] {
      min-width: 48px;
      min-height: 48px;
      font-size: 0.9em;
      border-radius: 8px;
      margin: 2px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      color: #333;
      cursor: pointer;
      outline: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.03);
    }
    input[type="range"] {
      width: 200px;
    }
    .main-actions {
      margin: 15px 0 15px 0;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .main-actions button {
      min-width: 100px;
      min-height: 48px;
      font-size: 1.09em;
      border-radius: 8px;
      margin: 5px 3px;
      padding: 7px 20px;
      font-weight: bold;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.09);
      transition: background 0.2s;
    }
    .main-actions .primary { background: #3bc654; color: #fff;}
    .main-actions .secondary { background: #3687eb; color: #fff;}
    #canvasContainer {
      width: 100%;
      max-width: 400px;
      border: 2px solid #bbb;
      border-radius: 0;
      box-shadow: 0 4px 24px rgba(0,0,0,0.14);
      background: #eee;
      position: relative;
      overflow: hidden;
      display: flex;
      margin-left: auto;
      margin-right: auto;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 0;
      user-select: none;
      background: #f5f5f5;
    }
    @media (max-width: 540px) {
      .container {
        border-radius: 0;
        padding: 12px;
      }
      #canvasContainer {
        max-width: 95vw;
        border-radius: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>9:16 Komposition erstellen</h1>
    
    <div class="controls">
      <div class="upload-controls">
        <label>
          Hintergrundbild:
          <input type="file" id="backgroundUpload" accept="image/*" />
        </label>
        <label>
          Overlay-Bild:
          <input type="file" id="overlayUpload" accept="image/*" />
        </label>
      </div>
      <div class="circle-controls">
        <div class="circle-group" id="lowerCircleControls">
          <span>Unterer Kreis Größe:</span>
          <input type="range" id="lowerCircleRadius" min="30" max="500" value="120"/>
        </div>
        <div class="circle-group" id="upperCircleControls">
          <span>Overlay-Kreis Bild-Zoom:</span>
          <input type="range" id="upperCircleZoom" min="100" max="450" value="150" step="1"/>
        </div>
        <div class="circle-group" id="upperCircleSizeControls">
          <span>Overlay-Kreis Größe:</span>
          <input type="range" id="upperCircleRadius" min="30" max="500" value="400"/>
        </div>
      </div>
      <div class="main-actions">
        <button id="resetBtn" class="secondary">Zurücksetzen</button>
        <button id="downloadBtn" class="primary">Download PNG</button>
      </div>
    </div>
    
    <div id="canvasContainer">
      <canvas id="compositionCanvas"></canvas>
    </div>
  </div>
  <script>
/* Canvas Setup */
const canvas = document.getElementById('compositionCanvas');
const ctx = canvas.getContext('2d');

// Canvas auf feste Größe setzen
canvas.width = 1080;
canvas.height = 1920;

/* Hilfsfunktionen */
function clamp(val, min, max) { 
  return Math.max(min, Math.min(max, val)); 
}

/* State - Startwerte aus Slidern */
let state = {
  bgImg: null,
  overlayImg: null,
  upper: {
    x: 540, 
    y: 700, 
    radius: 400,
    imgOffsetX: 0, 
    imgOffsetY: 0, 
    zoom: 1.5,
    rotation: 0,
    minZoom: 1.0, 
    maxZoom: 4.5
  },
  lower: {
    x: 540, 
    y: 1400, 
    radius: 120
  }
};

/* Interaktionsvariablen */
let activeCircle = null;
let interactionMode = 'none';
let dragStart = null;
let panStart = null;
let lastTouches = [];
let initialPinchDistance = 0;
let initialPinchAngle = 0;
let initialZoom = 1;
let initialRotation = 0;
let initialImgOffset = {x: 0, y: 0};

/* Default-Bilder laden beim Start */
function loadDefaultImages() {
  // Hintergrundbild laden
  let bgImg = new Image();
  bgImg.onload = () => {
    state.bgImg = bgImg;
    draw();
  };
  bgImg.onerror = () => {
    console.log('Hintergrundbild default.jpg nicht gefunden');
    draw();
  };
  bgImg.src = 'default.jpg';
  
  // Overlay-Bild laden
  let overlayImg = new Image();
  overlayImg.onload = () => {
    state.overlayImg = overlayImg;
    draw();
  };
  overlayImg.onerror = () => {
    console.log('Overlay-Bild default.jpg nicht gefunden');
    draw();
  };
  overlayImg.src = 'default.jpg';
}

// Default-Bilder beim Laden der Seite laden
loadDefaultImages();

/* File-Handling */
document.getElementById('backgroundUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    let img = new Image();
    img.onload = () => {
      state.bgImg = img;
      draw();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('overlayUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    let img = new Image();
    img.onload = () => {
      state.overlayImg = img;
      draw();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

/* UI-Controls */
document.getElementById('upperCircleZoom').addEventListener('input',e=>{
  state.upper.zoom = Number(e.target.value) / 100;
  draw();
});

document.getElementById('upperCircleRadius').addEventListener('input',e=>{
  state.upper.radius = Number(e.target.value);
  draw();
});

document.getElementById('lowerCircleRadius').addEventListener('input',e=>{
  state.lower.radius = Number(e.target.value);
  draw();
});

/* Reset */
document.getElementById('resetBtn').addEventListener('click',()=>{
  state.upper = { 
    x:540, y:700, radius:400,
    imgOffsetX:0, imgOffsetY:0, zoom:1.5, rotation:0,
    minZoom:1.0, maxZoom:4.5 
  };
  state.lower = { x:540, y:1400, radius:120 };
  document.getElementById('upperCircleZoom').value = 150;
  document.getElementById('upperCircleRadius').value = 400;
  document.getElementById('lowerCircleRadius').value = 120;
  draw();
});

/* Download PNG */
document.getElementById('downloadBtn').addEventListener('click',()=>{
  let url = canvas.toDataURL("image/png");
  let a = document.createElement('a');
  a.href = url;
  a.download = '9-16-komposition.png';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>document.body.removeChild(a),200);
});

/* Hilfsfunktionen für Touch/Mouse */
function getCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

function distance(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function insideCircle(pos, circle) {
  return distance(pos, circle) < circle.radius;
}

function getTouchCenter(t1, t2) {
  return {
    x: (t1.x + t2.x) / 2,
    y: (t1.y + t2.y) / 2
  };
}

function getTouchAngle(t1, t2) {
  return Math.atan2(t2.y - t1.y, t2.x - t1.x) * 180 / Math.PI;
}

/* Event Handlers */
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

canvas.addEventListener('touchstart', handleStart, {passive: false});
canvas.addEventListener('touchmove', handleMove, {passive: false});
canvas.addEventListener('touchend', handleEnd, {passive: false});

function handleStart(e) {
  // Bei einem Finger außerhalb der Kreise: normales Scrolling erlauben
  if (e.touches && e.touches.length === 1) {
    const pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    
    // Prüfe ob Touch in einem Kreis ist
    const inUpperCircle = insideCircle(pos, state.upper);
    const inLowerCircle = insideCircle(pos, state.lower);
    
    // Wenn außerhalb beider Kreise: Scrolling erlauben (preventDefault NICHT aufrufen)
    if (!inUpperCircle && !inLowerCircle) {
      return; // Normale Scroll-Funktion bleibt aktiv
    }
  }
  
  // Ansonsten preventDefault für Canvas-Interaktionen
  e.preventDefault();
  
  let pos;
  
  // EIN-FINGER Touch oder Maus
  if ((e.touches && e.touches.length === 1) || e.clientX !== undefined) {
    if (e.touches) {
      pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    } else {
      pos = getCanvasCoords(e.clientX, e.clientY);
    }
    
    // Oberer Kreis: Kreis verschieben
    if (insideCircle(pos, state.upper)) {
      activeCircle = 'upper';
      interactionMode = 'moveCircle';
      dragStart = pos;
      panStart = { x: state.upper.x, y: state.upper.y };
    } 
    // Unterer Kreis: Kreis verschieben
    else if (insideCircle(pos, state.lower)) {
      activeCircle = 'lower';
      interactionMode = 'moveCircle';
      dragStart = pos;
      panStart = { x: state.lower.x, y: state.lower.y };
    }
  } 
  // ZWEI-FINGER Touch
  else if (e.touches && e.touches.length === 2) {
    const t1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    const t2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
    const center = getTouchCenter(t1, t2);
    
    // Oberer Kreis: Bild manipulieren (Zoom, Rotation, Panning)
    if (insideCircle(center, state.upper)) {
      activeCircle = 'upper';
      interactionMode = 'manipulateImage';
      lastTouches = [t1, t2];
      initialPinchDistance = distance(t1, t2);
      initialPinchAngle = getTouchAngle(t1, t2);
      initialZoom = state.upper.zoom;
      initialRotation = state.upper.rotation;
      initialImgOffset = { x: state.upper.imgOffsetX, y: state.upper.imgOffsetY };
    } 
    // Unterer Kreis: Kreisgröße ändern
    else if (insideCircle(center, state.lower)) {
      activeCircle = 'lower';
      interactionMode = 'resizeCircle';
      lastTouches = [t1, t2];
      initialPinchDistance = distance(t1, t2);
      panStart = { radius: state.lower.radius };
    }
  }
}

function handleMove(e) {
  // Scrolling erlauben wenn keine Interaktion aktiv ist
  if (!activeCircle) {
    return; // Normale Scroll-Funktion bleibt aktiv
  }
  
  e.preventDefault();
  
  // ZWEI-FINGER Manipulation
  if (e.touches && e.touches.length === 2 && lastTouches.length === 2) {
    const t1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    const t2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
    
    if (activeCircle === 'upper' && interactionMode === 'manipulateImage') {
      // Berechne Änderungen
      const currentDistance = distance(t1, t2);
      const currentAngle = getTouchAngle(t1, t2);
      const currentCenter = getTouchCenter(t1, t2);
      const lastCenter = getTouchCenter(lastTouches[0], lastTouches[1]);
      
      // ZOOM (Pinch)
      const zoomScale = currentDistance / initialPinchDistance;
      state.upper.zoom = clamp(initialZoom * zoomScale, state.upper.minZoom, state.upper.maxZoom);
      document.getElementById('upperCircleZoom').value = state.upper.zoom * 100;
      
      // ROTATION
      const angleDelta = currentAngle - initialPinchAngle;
      state.upper.rotation = initialRotation + angleDelta;
      
      // PANNING (Bildverschiebung)
      const panDeltaX = currentCenter.x - lastCenter.x;
      const panDeltaY = currentCenter.y - lastCenter.y;
      state.upper.imgOffsetX = initialImgOffset.x + (currentCenter.x - getTouchCenter(lastTouches[0], lastTouches[1]).x);
      state.upper.imgOffsetY = initialImgOffset.y + (currentCenter.y - getTouchCenter(lastTouches[0], lastTouches[1]).y);
      
      draw();
      return;
    } 
    else if (activeCircle === 'lower' && interactionMode === 'resizeCircle') {
      // Unterer Kreis: Größe ändern
      const currentDistance = distance(t1, t2);
      const scale = currentDistance / initialPinchDistance;
      state.lower.radius = clamp(panStart.radius * scale, 30, 500);
      document.getElementById('lowerCircleRadius').value = state.lower.radius;
      draw();
      return;
    }
  }
  
  // EIN-FINGER Bewegung (Kreis verschieben)
  if (!dragStart) return;
  
  let pos;
  if (e.touches && e.touches.length === 1) {
    pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
  } else if (e.clientX !== undefined) {
    pos = getCanvasCoords(e.clientX, e.clientY);
  }
  
  if (!pos) return;
  
  if (interactionMode === 'moveCircle') {
    if (activeCircle === 'upper') {
      // Oberen Kreis verschieben
      state.upper.x = clamp(panStart.x + (pos.x - dragStart.x), state.upper.radius, canvas.width - state.upper.radius);
      state.upper.y = clamp(panStart.y + (pos.y - dragStart.y), state.upper.radius, canvas.height - state.upper.radius);
    } else if (activeCircle === 'lower') {
      // Unteren Kreis verschieben
      state.lower.x = clamp(panStart.x + (pos.x - dragStart.x), state.lower.radius, canvas.width - state.lower.radius);
      state.lower.y = clamp(panStart.y + (pos.y - dragStart.y), state.lower.radius, canvas.height - state.lower.radius);
    }
    draw();
  }
}

function handleEnd(e) {
  if (activeCircle) {
    e.preventDefault();
  }
  activeCircle = null;
  interactionMode = 'none';
  dragStart = null;
  panStart = null;
  lastTouches = [];
}

/* Drawing */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Hintergrund
  if (state.bgImg) {
    ctx.drawImage(state.bgImg, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = "#e0e0e8";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  
  // Verbindungslinie (nur außerhalb der Kreise)
  const dist = distance(state.upper, state.lower);
  if (dist > state.upper.radius + state.lower.radius) {
    const angle = Math.atan2(state.lower.y - state.upper.y, state.lower.x - state.upper.x);
    const startX = state.upper.x + Math.cos(angle) * state.upper.radius;
    const startY = state.upper.y + Math.sin(angle) * state.upper.radius;
    const endX = state.lower.x - Math.cos(angle) * state.lower.radius;
    const endY = state.lower.y - Math.sin(angle) * state.lower.radius;
    
    ctx.save();
    ctx.shadowColor = "rgba(0,0,0,0.8)";
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 5;
    ctx.shadowOffsetY = 5;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 16;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.restore();
  }
  
  // Unterer Kreis - nur Outline
  drawCircleOutline(state.lower.x, state.lower.y, state.lower.radius);
  
  // Oberer Kreis - weiße Füllung
  drawCircleFilled(state.upper.x, state.upper.y, state.upper.radius, "#ffffff");
  
  // Overlay-Bild mit Rotation
  if (state.overlayImg) {
    ctx.save();
    
    // Clip für Kreis
    ctx.beginPath();
    ctx.arc(state.upper.x, state.upper.y, state.upper.radius - 4, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    
    // Transformationen: erst zum Kreismittelpunkt, dann rotieren
    ctx.translate(state.upper.x, state.upper.y);
    ctx.rotate(state.upper.rotation * Math.PI / 180);
    ctx.translate(-state.upper.x, -state.upper.y);
    
    // Cover-Modus berechnen
    const imgAspect = state.overlayImg.width / state.overlayImg.height;
    const circleSize = (state.upper.radius - 4) * 2;
    
    let drawWidth, drawHeight;
    
    if (imgAspect > 1) {
      drawHeight = circleSize * state.upper.zoom;
      drawWidth = drawHeight * imgAspect;
    } else {
      drawWidth = circleSize * state.upper.zoom;
      drawHeight = drawWidth / imgAspect;
    }
    
    const minSize = circleSize * state.upper.zoom;
    if (drawWidth < minSize) {
      drawWidth = minSize;
      drawHeight = drawWidth / imgAspect;
    }
    if (drawHeight < minSize) {
      drawHeight = minSize;
      drawWidth = drawHeight * imgAspect;
    }
    
    // Bild zeichnen mit Offset
    ctx.drawImage(
      state.overlayImg,
      state.upper.x - drawWidth/2 + state.upper.imgOffsetX,
      state.upper.y - drawHeight/2 + state.upper.imgOffsetY,
      drawWidth,
      drawHeight
    );
    
    ctx.restore();
  }
  
  // Outline für oberen Kreis
  drawCircleOutline(state.upper.x, state.upper.y, state.upper.radius);
}

function drawCircleFilled(x, y, radius, fillColor) {
  ctx.save();
  ctx.fillStyle = fillColor;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawCircleOutline(x, y, radius) {
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.8)";
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 5;
  ctx.shadowOffsetY = 5;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 16;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

/* Initial Draw */
draw();
  </script>
</body>
</html>