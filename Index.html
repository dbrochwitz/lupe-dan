<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>9:16 Bild-Editor – Bildausschnitt steuerbar</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f5f5f5;
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
  }
  .container {
    background: white;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 30px;
  }
  h1 { text-align: center; }
  #canvasWrapper { text-align: center; }
  canvas {
    border: 2px solid #ddd;
    border-radius: 5px;
    max-width: 100%;
    background: #fff;
    cursor: default;
  }
  canvas.dragging { cursor: move; }
  button {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    margin: 5px;
    cursor: pointer;
  }
  button.secondary { background: #2196F3; }
</style>
</head>
<body>
<div class="container">
  <h1>9:16 Bild-Editor</h1>
  <div>
    <label>Hintergrundbild:</label>
    <input type="file" id="backgroundUpload" accept="image/*"><br>
    <label>Overlay-Bild (oberer Kreis):</label>
    <input type="file" id="overlayUpload1" accept="image/*">
  </div>

  <div id="canvasWrapper">
    <canvas id="canvas" width="1080" height="1920"></canvas>
  </div>

  <div style="text-align:center">
    <button onclick="resetCanvas()">Zurücksetzen</button>
    <button class="secondary" onclick="downloadImage()">Download</button>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let backgroundImg = new Image();
let overlayImg1 = new Image();
let imagesLoaded = 0;

// === Eigenschaften der Elemente ===
let overlay1 = {
  x:540, y:600, radius:150, rotation:0,
  imgOffsetX:0, imgOffsetY:0, imgScale:1,
  isDragging:false, movingImage:false
};
let overlay2 = { x:540, y:1320, radius:150, isDragging:false };
let activeOverlay = null;
let startX, startY;

// === Zeichenfunktionen ===
function redraw() {
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (backgroundImg.complete) ctx.drawImage(backgroundImg,0,0,canvas.width,canvas.height);

  drawConnectionLine();
  drawOverlay1();
  drawOverlay2();
}

function drawConnectionLine() {
  const dx = overlay2.x - overlay1.x;
  const dy = overlay2.y - overlay1.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist <= overlay1.radius + overlay2.radius) return;
  const angle = Math.atan2(dy, dx);
  const x1 = overlay1.x + Math.cos(angle)*overlay1.radius;
  const y1 = overlay1.y + Math.sin(angle)*overlay1.radius;
  const x2 = overlay2.x - Math.cos(angle)*overlay2.radius;
  const y2 = overlay2.y - Math.sin(angle)*overlay2.radius;

  ctx.save();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 8;
  ctx.shadowColor = 'rgba(0,0,0,0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 5;
  ctx.shadowOffsetY = 5;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.restore();
}

// Bild im Kreis – mit Offset und Zoom
function drawImageCover(ctx, img, circle) {
  const r = circle.radius;
  const iw = img.width;
  const ih = img.height;
  const baseScale = Math.max((r*2) / iw, (r*2) / ih);
  const totalScale = baseScale * circle.imgScale;
  const dw = iw * totalScale;
  const dh = ih * totalScale;

  ctx.save();
  ctx.translate(circle.x, circle.y);
  ctx.rotate(circle.rotation * Math.PI / 180);
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.clip();
  ctx.drawImage(img, -dw/2 + circle.imgOffsetX, -dh/2 + circle.imgOffsetY, dw, dh);
  ctx.restore();
}

function drawOverlay1() {
  if (!overlayImg1.complete) return;

  // Schatten außerhalb des Kreises
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 5;
  ctx.shadowOffsetY = 5;
  ctx.beginPath();
  ctx.arc(overlay1.x, overlay1.y, overlay1.radius, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Bild mit Steuerung für Ausschnitt
  drawImageCover(ctx, overlayImg1, overlay1);

  // Outline
  ctx.save();
  ctx.beginPath();
  ctx.arc(overlay1.x, overlay1.y, overlay1.radius, 0, Math.PI*2);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 8;
  ctx.stroke();
  ctx.restore();
}

function drawOverlay2() {
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 5;
  ctx.shadowOffsetY = 5;
  ctx.beginPath();
  ctx.arc(overlay2.x, overlay2.y, overlay2.radius, 0, Math.PI*2);
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 8;
  ctx.stroke();
  ctx.restore();
}

// === Interaktion ===
function isInsideCircle(mx, my, o) {
  const dx = mx - o.x;
  const dy = my - o.y;
  return Math.sqrt(dx*dx + dy*dy) <= o.radius;
}

canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  if (isInsideCircle(mx,my,overlay1)) {
    activeOverlay = overlay1;
    startX = mx - overlay1.x;
    startY = my - overlay1.y;
    overlay1.isDragging = !e.shiftKey;
    overlay1.movingImage = e.shiftKey;
  } else if (isInsideCircle(mx,my,overlay2)) {
    activeOverlay = overlay2;
    startX = mx - overlay2.x;
    startY = my - overlay2.y;
    overlay2.isDragging = true;
  }

  if (activeOverlay) canvas.classList.add('dragging');
});

canvas.addEventListener('mousemove', e => {
  if (!activeOverlay) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  if (activeOverlay.isDragging) {
    activeOverlay.x = mx - startX;
    activeOverlay.y = my - startY;
  } else if (activeOverlay.movingImage) {
    overlay1.imgOffsetX += (mx - overlay1.x - startX) * 0.2;
    overlay1.imgOffsetY += (my - overlay1.y - startY) * 0.2;
  }

  redraw();
});

canvas.addEventListener('mouseup', () => {
  if (activeOverlay) {
    activeOverlay.isDragging = false;
    activeOverlay.movingImage = false;
  }
  activeOverlay = null;
  canvas.classList.remove('dragging');
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);
  let target = null;
  if (isInsideCircle(mx,my,overlay1)) target = overlay1;
  else if (isInsideCircle(mx,my,overlay2)) target = overlay2;
  if (!target) return;

  if (e.ctrlKey && target === overlay1) {
    const factor = e.deltaY > 0 ? 0.95 : 1.05;
    target.imgScale = Math.min(Math.max(target.imgScale * factor, 0.5), 3);
  } else if (e.shiftKey && target === overlay1) {
    target.rotation += e.deltaY > 0 ? 5 : -5;
  } else {
    const factor = e.deltaY > 0 ? 0.95 : 1.05;
    target.radius = Math.max(30, Math.min(500, target.radius * factor));
  }
  redraw();
}, { passive: false });

// === Uploads ===
document.getElementById('backgroundUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => { backgroundImg = img; redraw(); };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('overlayUpload1').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    const img = new Image();
    img.onload = () => { overlayImg1 = img; redraw(); };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

// === Reset & Download ===
function resetCanvas() {
  overlay1 = { x:540,y:600,radius:150,rotation:0,imgOffsetX:0,imgOffsetY:0,imgScale:1,isDragging:false,movingImage:false };
  overlay2 = { x:540,y:1320,radius:150,isDragging:false };
  redraw();
}

function downloadImage() {
  const a = document.createElement('a');
  a.download = '9-16-komposition.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
}

// === Standardbilder ===
backgroundImg.src = 'default.jpg';
overlayImg1.src = 'default.jpg';
backgroundImg.onload = overlayImg1.onload = function() { imagesLoaded++; if (imagesLoaded === 2) redraw(); };
</script>
</body>
</html>
