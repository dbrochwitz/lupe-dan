<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>PflanzenUndCo.de | #Leafporn</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;900&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #ececec;
      font-family: system-ui, sans-serif;
      min-height: 100vh;
    }
    .container {
      max-width: 800px;
      margin: 0 auto 2em auto;
      background: #fff;
      box-shadow: 0 8px 32px rgba(0,0,0,0.10);
      border-radius: 24px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      text-align: center;
      font-size: 1.5em;
      margin-bottom: 0.75em;
      margin-top: 0.5em;
    }
    .controls {
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1em;
    }
    .upload-controls {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 10px;
    }
    .upload-controls label {
      display: block;
      font-weight: 500;
      margin-bottom: 4px;
    }
    .upload-controls input[type="file"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
    }
    .upload-controls textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
      font-family: 'Roboto', sans-serif;
      font-weight: 900;
      font-size: 14px;
      resize: vertical;
      min-height: 60px;
    }
    .circle-controls {
      margin-bottom: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      align-items: center;
    }
    .circle-group {
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    .circle-group span {
      font-weight:500;
      margin-right:6px;
      min-width: 100%;
      text-align: center;
      margin-bottom: 4px;
    }
    input[type="range"] {
      width: 100%;
      height: 48px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
    }
    /* Slider Track - Chrome, Safari, Edge */
    input[type="range"]::-webkit-slider-track {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      border: none;
    }
    /* Slider Track - Firefox */
    input[type="range"]::-moz-range-track {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
      border: none;
    }
    /* iOS Safari - zusätzlicher Track */
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
      height: 8px;
      background: #ddd;
      border-radius: 4px;
    }
    /* Slider Thumb - Chrome, Safari, Edge */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 32px;
      height: 32px;
      background: #3687eb;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      border: none;
    }
    /* Slider Thumb - Firefox */
    input[type="range"]::-moz-range-thumb {
      width: 32px;
      height: 32px;
      background: #3687eb;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    /* Active state - Chrome, Safari, Edge */
    input[type="range"]:active::-webkit-slider-thumb {
      background: #2a6bcf;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    /* Active state - Firefox */
    input[type="range"]:active::-moz-range-thumb {
      background: #2a6bcf;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
    }
    .color-picker-section {
      margin-top: 15px;
      text-align: center;
      font-weight: 500;
    }
    .color-picker-section label {
      display: block;
      margin-bottom: 8px;
    }
    .color-picker-section input[type="color"] {
      width: 60px;
      height: 40px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    .main-actions {
      margin: 15px 0 15px 0;
      display: flex;
      justify-content: center;
      gap: 10px;
      width: 100%;
      max-width: 400px;
    }
    .main-actions button {
      min-width: 100px;
      min-height: 48px;
      font-size: 1.09em;
      border-radius: 8px;
      margin: 5px 3px;
      padding: 7px 20px;
      font-weight: bold;
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.09);
      transition: background 0.2s;
    }
    .main-actions .primary { background: #3bc654; color: #fff;}
    .main-actions .secondary { background: #3687eb; color: #fff;}
    #canvasContainer {
      width: 100%;
      max-width: 400px;
      border: 2px solid #bbb;
      border-radius: 0;
      box-shadow: 0 4px 24px rgba(0,0,0,0.14);
      background: #eee;
      position: relative;
      overflow: hidden;
      display: flex;
      margin-left: auto;
      margin-right: auto;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 0;
      user-select: none;
      background: #f5f5f5;
    }
    @media (max-width: 540px) {
      .container {
        border-radius: 0;
        padding: 12px;
      }
      #canvasContainer {
        max-width: 95vw;
        border-radius: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>PflanzenUndCo.de | #Leafporn</h1>
    
    <div class="controls">
      <div class="upload-controls">
        <label>
          Hintergrundbild:
          <input type="file" id="backgroundUpload" accept="image/*" />
        </label>
        <label>
          Overlay-Bild:
          <input type="file" id="overlayUpload" accept="image/*" />
        </label>
        <label>
          Text auf Bild (Enter für neue Zeile, * am Anfang für Balken):
          <textarea id="textInput" placeholder="Text eingeben..." rows="3">Jede Zeile
*mit Sternchen
macht einen Balken</textarea>
        </label>
      </div>
      <div class="circle-controls">
        <div class="circle-group" id="lowerCircleControls">
          <span>Unterer Kreis Größe:</span>
          <input type="range" id="lowerCircleRadius" min="30" max="500" value="120"/>
        </div>
        <div class="circle-group" id="upperCircleControls">
          <span>Overlay-Kreis Bild-Zoom:</span>
          <input type="range" id="upperCircleZoom" min="100" max="450" value="150" step="1"/>
        </div>
        <div class="circle-group" id="upperCircleSizeControls">
          <span>Overlay-Kreis Größe:</span>
          <input type="range" id="upperCircleRadius" min="30" max="500" value="400"/>
        </div>
      </div>
    </div>
    
    <div id="canvasContainer">
      <canvas id="compositionCanvas"></canvas>
    </div>

    <div class="color-picker-section">
      <label for="colorPicker">Textfarbe (STRG+Klick auf Bild):</label>
      <input type="color" id="colorPicker" value="#ffffff" />
    </div>

    <div class="main-actions">
      <button id="resetBtn" class="secondary">Zurücksetzen</button>
      <button id="downloadBtn" class="primary">Download PNG</button>
    </div>
  </div>
  <script>
/* Canvas Setup */
const canvas = document.getElementById('compositionCanvas');
const ctx = canvas.getContext('2d');

// Canvas auf feste Größe setzen
canvas.width = 1080;
canvas.height = 1920;

/* Hilfsfunktionen */
function clamp(val, min, max) { 
  return Math.max(min, Math.min(max, val)); 
}

/* State - Startwerte aus Slidern */
let state = {
  bgImg: null,
  overlayImg: null,
  watermarkImg: null,
  text: {
    content: '',
    lines: [],
    x: 540,
    y: 960,
    boxWidth: 600,
    rotation: 0,
    color: '#ffffff',
    lineHeight: 1.1
  },
  upper: {
    x: 540, 
    y: 700, 
    radius: 400,
    imgOffsetX: 0, 
    imgOffsetY: 0, 
    zoom: 1.5,
    rotation: 0,
    minZoom: 1.0, 
    maxZoom: 4.5
  },
  lower: {
    x: 540, 
    y: 1400, 
    radius: 120
  }
};

/* Interaktionsvariablen */
let activeElement = null;
let interactionMode = 'none';
let dragStart = null;
let panStart = null;
let lastTouches = [];
let initialPinchDistance = 0;
let initialPinchAngle = 0;
let initialZoom = 1;
let initialRotation = 0;
let initialImgOffset = {x: 0, y: 0};
let initialBoxWidth = 600;

/* Mausrad-Variablen */
let lastClickedElement = null;

/* STRG-Taste Status */
let ctrlPressed = false;

// Track STRG-Taste
document.addEventListener('keydown', (e) => {
  if (e.key === 'Control') {
    ctrlPressed = true;
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'Control') {
    ctrlPressed = false;
  }
});

/* Default-Bilder laden beim Start */
function loadDefaultImages() {
  let bgImg = new Image();
  bgImg.onload = () => {
    state.bgImg = bgImg;
    draw();
  };
  bgImg.onerror = () => {
    console.log('Hintergrundbild default.jpg nicht gefunden');
    draw();
  };
  bgImg.src = 'default.jpg';
  
  let overlayImg = new Image();
  overlayImg.onload = () => {
    state.overlayImg = overlayImg;
    draw();
  };
  overlayImg.onerror = () => {
    console.log('Overlay-Bild default.jpg nicht gefunden');
    draw();
  };
  overlayImg.src = 'default.jpg';
  
  let watermarkImg = new Image();
  watermarkImg.onload = () => {
    state.watermarkImg = watermarkImg;
    draw();
  };
  watermarkImg.onerror = () => {
    console.log('Wasserzeichen watermark.png nicht gefunden');
  };
  watermarkImg.src = 'watermark.png';
  
  // Text initialisieren nach Bildern
  setTimeout(() => {
    document.getElementById('textInput').dispatchEvent(new Event('input'));
    draw();
  }, 50);
}

loadDefaultImages();

/* File-Handling */
document.getElementById('backgroundUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    let img = new Image();
    img.onload = () => {
      state.bgImg = img;
      draw();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('overlayUpload').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    let img = new Image();
    img.onload = () => {
      state.overlayImg = img;
      draw();
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
});

// Text Input - Großbuchstaben + Trim + Stern-Marker
document.getElementById('textInput').addEventListener('input', e => {
  state.text.content = e.target.value;
  state.text.lines = e.target.value.split('\n')
    .map(line => line.trim().toUpperCase())
    .filter(line => line.length > 0);
  draw();
});

// Color Picker
document.getElementById('colorPicker').addEventListener('input', e => {
  state.text.color = e.target.value;
  draw();
});

// Canvas Click für Farbauswahl
canvas.addEventListener('click', e => {
  if (e.ctrlKey || e.shiftKey) {
    e.preventDefault();
    const pos = getCanvasCoords(e.clientX, e.clientY);
    
    // Hole Pixel-Farbe an dieser Position
    const pixel = ctx.getImageData(pos.x, pos.y, 1, 1).data;
    const hexColor = '#' + 
      ('0' + pixel[0].toString(16)).slice(-2) +
      ('0' + pixel[1].toString(16)).slice(-2) +
      ('0' + pixel[2].toString(16)).slice(-2);
    
    state.text.color = hexColor;
    document.getElementById('colorPicker').value = hexColor;
    draw();
  }
});

/* UI-Controls */
document.getElementById('upperCircleZoom').addEventListener('input',e=>{
  state.upper.zoom = Number(e.target.value) / 100;
  draw();
});

document.getElementById('upperCircleRadius').addEventListener('input',e=>{
  state.upper.radius = Number(e.target.value);
  draw();
});

document.getElementById('lowerCircleRadius').addEventListener('input',e=>{
  state.lower.radius = Number(e.target.value);
  draw();
});

/* Reset */
document.getElementById('resetBtn').addEventListener('click',()=>{
  state.upper = { 
    x:540, y:700, radius:400,
    imgOffsetX:0, imgOffsetY:0, zoom:1.5, rotation:0,
    minZoom:1.0, maxZoom:4.5 
  };
  state.lower = { x:540, y:1400, radius:120 };
  state.text = {
    content: state.text.content,
    lines: state.text.lines,
    x: 540,
    y: 960,
    boxWidth: 600,
    rotation: 0,
    color: '#ffffff',
    lineHeight: 1.1
  };
  document.getElementById('upperCircleZoom').value = 150;
  document.getElementById('upperCircleRadius').value = 400;
  document.getElementById('lowerCircleRadius').value = 120;
  document.getElementById('colorPicker').value = '#ffffff';
  lastClickedElement = null;
  draw();
});

/* Download PNG */
document.getElementById('downloadBtn').addEventListener('click',()=>{
  canvas.toBlob((blob) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = '9-16-komposition.png';
    document.body.appendChild(a);
    a.click();
    
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
  }, 'image/png');
});

/* Hilfsfunktionen für Touch/Mouse */
function getCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

function distance(p1, p2) {
  const dx = p1.x - p2.x;
  const dy = p1.y - p2.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function insideCircle(pos, circle) {
  return distance(pos, circle) < circle.radius;
}

function insideText(pos) {
  if (!state.text.content || state.text.lines.length === 0) return false;
  
  const lineData = calculateLineData();
  let totalHeight = 0;
  for (let i = 0; i < lineData.length; i++) {
    totalHeight += lineData[i].totalLineHeight;
  }
  
  const dx = pos.x - state.text.x;
  const dy = pos.y - state.text.y;
  const angle = -state.text.rotation * Math.PI / 180;
  const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
  const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);
  
  return (
    rotatedX >= -state.text.boxWidth / 2 &&
    rotatedX <= state.text.boxWidth / 2 &&
    rotatedY >= -totalHeight / 2 &&
    rotatedY <= totalHeight / 2
  );
}

function getTouchCenter(t1, t2) {
  return {
    x: (t1.x + t2.x) / 2,
    y: (t1.y + t2.y) / 2
  };
}

function getTouchAngle(t1, t2) {
  return Math.atan2(t2.y - t1.y, t2.x - t1.x) * 180 / Math.PI;
}

/* Berechne Schriftgröße für jede Zeile */
function calculateLineData() {
  const lineData = [];
  
  // Prüfe ob es Zeilen mit Stern gibt
  const hasAnyMarker = state.text.lines.some(line => line.startsWith('*'));
  
  // Wenn keine Stern-Zeilen: finde längste Zeile
  let longestLineIndex = -1;
  if (!hasAnyMarker) {
    let longestWidth = 0;
    for (let i = 0; i < state.text.lines.length; i++) {
      const line = state.text.lines[i];
      ctx.font = '900 100px "Roboto", sans-serif';
      const lineWidth = ctx.measureText(line).width;
      if (lineWidth > longestWidth) {
        longestWidth = lineWidth;
        longestLineIndex = i;
      }
    }
  }
  
  for (let i = 0; i < state.text.lines.length; i++) {
    const line = state.text.lines[i];
    
    // Prüfe ob Zeile mit * beginnt
    const hasMarker = line.startsWith('*');
    const displayText = hasMarker ? line.substring(1).trim() : line;
    
    // Balken wenn: Stern vorhanden ODER (keine Sterne UND längste Zeile)
    const getBalken = hasMarker || (!hasAnyMarker && i === longestLineIndex);
    
    const charCount = displayText.length;
    const fontWeight = charCount > 10 ? 400 : 900;
    
    let fontSize = 20;
    let textWidth = 0;
    
    // Binäre Suche für optimale Schriftgröße
    let minSize = 20;
    let maxSize = 300;
    
    // Für Zeilen mit Balken: Berechne Padding (halbe Breite von "I")
    let textBoxWidth = state.text.boxWidth;
    if (getBalken) {
      // Messe "I" Breite für Padding (halbiert)
      ctx.font = `${fontWeight} 100px 'Roboto', sans-serif`;
      const iPadding = ctx.measureText('I').width / 2;
      textBoxWidth = state.text.boxWidth - (iPadding * 2);
    }
    
    // Bei letzter Zeile mit Wasserzeichen: Platz für Wasserzeichen einrechnen
    const isLastLine = (i === state.text.lines.length - 1);
    let textBoxWidthWithWatermark = textBoxWidth;
    
    for (let j = 0; j < 20; j++) {
      fontSize = (minSize + maxSize) / 2;
      ctx.font = `${fontWeight} ${fontSize}px 'Roboto', sans-serif`;
      textWidth = ctx.measureText(displayText).width;
      
      // Bei letzter Zeile: reduzierter Platz für Text
      let availableWidth = textBoxWidth;
      if (isLastLine && state.watermarkImg) {
        availableWidth = textBoxWidth - (fontSize * 0.95);
        if (getBalken) {
          ctx.font = `${fontWeight} 100px 'Roboto', sans-serif`;
          const iPadding = ctx.measureText('I').width / 2;
          availableWidth = state.text.boxWidth - (iPadding * 2) - (fontSize * 0.95);
        }
      }
      
      if (textWidth < availableWidth) {
        minSize = fontSize;
      } else {
        maxSize = fontSize;
      }
    }
    
    fontSize = minSize * 0.98;
    
    const underlineThickness = fontWeight === 900 ? fontSize * 0.1 : fontSize * 0.05;
    
    // Berechne tatsächliches Padding für "I" (halbiert)
    ctx.font = `${fontWeight} ${fontSize}px 'Roboto', sans-serif`;
    const actualIPadding = getBalken ? ctx.measureText('I').width / 2 : 0;
    
    // Berechne Gesamthöhe der Zeile inkl. Spacing
    let totalLineHeight = fontSize * state.text.lineHeight;
    
    lineData.push({
      text: displayText,
      fontSize: fontSize,
      fontWeight: fontWeight,
      underlineThickness: underlineThickness,
      isLongestWord: getBalken,
      iPadding: actualIPadding,
      totalLineHeight: totalLineHeight,
      isLastLine: isLastLine
    });
  }
  
  return lineData;
}

/* Mausrad Event */
canvas.addEventListener('wheel', handleWheel, {passive: false});

function handleWheel(e) {
  e.preventDefault();
  
  const pos = getCanvasCoords(e.clientX, e.clientY);
  const delta = -Math.sign(e.deltaY);
  
  const overUpper = insideCircle(pos, state.upper);
  const overLower = insideCircle(pos, state.lower);
  const overText = insideText(pos);
  
  if (overUpper) {
    const zoomStep = 5;
    const newZoomPercent = clamp((state.upper.zoom * 100) + (delta * zoomStep), 100, 450);
    state.upper.zoom = newZoomPercent / 100;
    document.getElementById('upperCircleZoom').value = newZoomPercent;
    draw();
  } else if (overLower) {
    const radiusStep = 10;
    state.lower.radius = clamp(state.lower.radius + (delta * radiusStep), 30, 500);
    document.getElementById('lowerCircleRadius').value = state.lower.radius;
    draw();
  } else if (overText) {
    const widthStep = 20;
    state.text.boxWidth = clamp(state.text.boxWidth + (delta * widthStep), 200, 1000);
    draw();
  }
  else if (lastClickedElement === 'upper') {
    const zoomStep = 5;
    const newZoomPercent = clamp((state.upper.zoom * 100) + (delta * zoomStep), 100, 450);
    state.upper.zoom = newZoomPercent / 100;
    document.getElementById('upperCircleZoom').value = newZoomPercent;
    draw();
  } else if (lastClickedElement === 'lower') {
    const radiusStep = 10;
    state.lower.radius = clamp(state.lower.radius + (delta * radiusStep), 30, 500);
    document.getElementById('lowerCircleRadius').value = state.lower.radius;
    draw();
  } else if (lastClickedElement === 'text') {
    const widthStep = 20;
    state.text.boxWidth = clamp(state.text.boxWidth + (delta * widthStep), 200, 1000);
    draw();
  }
}

/* Event Handlers */
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

canvas.addEventListener('touchstart', handleStart, {passive: false});
canvas.addEventListener('touchmove', handleMove, {passive: false});
canvas.addEventListener('touchend', handleEnd, {passive: false});

function handleStart(e) {
  if (e.touches && e.touches.length === 1) {
    const pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    
    const inUpperCircle = insideCircle(pos, state.upper);
    const inLowerCircle = insideCircle(pos, state.lower);
    const inText = insideText(pos);
    
    if (!inUpperCircle && !inLowerCircle && !inText) {
      return;
    }
  }
  
  e.preventDefault();
  
  let pos;
  
  if ((e.touches && e.touches.length === 1) || e.clientX !== undefined) {
    if (e.touches) {
      pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    } else {
      pos = getCanvasCoords(e.clientX, e.clientY);
    }
    
    if (insideText(pos)) {
      activeElement = 'text';
      lastClickedElement = 'text';
      interactionMode = 'moveText';
      dragStart = pos;
      panStart = { x: state.text.x, y: state.text.y };
    }
    else if (insideCircle(pos, state.upper)) {
      activeElement = 'upper';
      lastClickedElement = 'upper';
      
      if (ctrlPressed) {
        interactionMode = 'panImage';
        dragStart = pos;
        panStart = { x: state.upper.imgOffsetX, y: state.upper.imgOffsetY };
      } else {
        interactionMode = 'moveCircle';
        dragStart = pos;
        panStart = { x: state.upper.x, y: state.upper.y };
      }
    } 
    else if (insideCircle(pos, state.lower)) {
      activeElement = 'lower';
      lastClickedElement = 'lower';
      interactionMode = 'moveCircle';
      dragStart = pos;
      panStart = { x: state.lower.x, y: state.lower.y };
    } else {
      lastClickedElement = null;
    }
  } 
  else if (e.touches && e.touches.length === 2) {
    const t1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    const t2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
    const center = getTouchCenter(t1, t2);
    
    if (insideText(center)) {
      activeElement = 'text';
      interactionMode = 'manipulateText';
      lastTouches = [t1, t2];
      initialPinchDistance = distance(t1, t2);
      initialPinchAngle = getTouchAngle(t1, t2);
      initialBoxWidth = state.text.boxWidth;
      initialRotation = state.text.rotation;
    }
    else if (insideCircle(center, state.upper)) {
      activeElement = 'upper';
      interactionMode = 'manipulateImage';
      lastTouches = [t1, t2];
      initialPinchDistance = distance(t1, t2);
      initialPinchAngle = getTouchAngle(t1, t2);
      initialZoom = state.upper.zoom;
      initialRotation = state.upper.rotation;
      initialImgOffset = { x: state.upper.imgOffsetX, y: state.upper.imgOffsetY };
    } 
    else if (insideCircle(center, state.lower)) {
      activeElement = 'lower';
      interactionMode = 'resizeCircle';
      lastTouches = [t1, t2];
      initialPinchDistance = distance(t1, t2);
      panStart = { radius: state.lower.radius };
    }
  }
}

function handleMove(e) {
  if (!activeElement) {
    return;
  }
  
  e.preventDefault();
  
  if (e.touches && e.touches.length === 2 && lastTouches.length === 2) {
    const t1 = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    const t2 = getCanvasCoords(e.touches[1].clientX, e.touches[1].clientY);
    
    if (activeElement === 'text' && interactionMode === 'manipulateText') {
      const currentDistance = distance(t1, t2);
      const currentAngle = getTouchAngle(t1, t2);
      
      const scale = currentDistance / initialPinchDistance;
      state.text.boxWidth = clamp(initialBoxWidth * scale, 200, 1000);
      
      const angleDelta = currentAngle - initialPinchAngle;
      const newRotation = initialRotation + angleDelta;
      state.text.rotation = Math.round(newRotation / 3) * 3;
      
      draw();
      return;
    }
    else if (activeElement === 'upper' && interactionMode === 'manipulateImage') {
      const currentDistance = distance(t1, t2);
      const currentAngle = getTouchAngle(t1, t2);
      const currentCenter = getTouchCenter(t1, t2);
      
      const zoomScale = currentDistance / initialPinchDistance;
      state.upper.zoom = clamp(initialZoom * zoomScale, state.upper.minZoom, state.upper.maxZoom);
      document.getElementById('upperCircleZoom').value = state.upper.zoom * 100;
      
      const angleDelta = currentAngle - initialPinchAngle;
      state.upper.rotation = initialRotation + angleDelta;
      
      state.upper.imgOffsetX = initialImgOffset.x + (currentCenter.x - getTouchCenter(lastTouches[0], lastTouches[1]).x);
      state.upper.imgOffsetY = initialImgOffset.y + (currentCenter.y - getTouchCenter(lastTouches[0], lastTouches[1]).y);
      
      draw();
      return;
    } 
    else if (activeElement === 'lower' && interactionMode === 'resizeCircle') {
      const currentDistance = distance(t1, t2);
      const scale = currentDistance / initialPinchDistance;
      state.lower.radius = clamp(panStart.radius * scale, 30, 500);
      document.getElementById('lowerCircleRadius').value = state.lower.radius;
      draw();
      return;
    }
  }
  
  if (!dragStart) return;
  
  let pos;
  if (e.touches && e.touches.length === 1) {
    pos = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
  } else if (e.clientX !== undefined) {
    pos = getCanvasCoords(e.clientX, e.clientY);
  }
  
  if (!pos) return;
  
  if (interactionMode === 'moveCircle') {
    if (activeElement === 'upper') {
      state.upper.x = clamp(panStart.x + (pos.x - dragStart.x), state.upper.radius, canvas.width - state.upper.radius);
      state.upper.y = clamp(panStart.y + (pos.y - dragStart.y), state.upper.radius, canvas.height - state.upper.radius);
    } else if (activeElement === 'lower') {
      state.lower.x = clamp(panStart.x + (pos.x - dragStart.x), state.lower.radius, canvas.width - state.lower.radius);
      state.lower.y = clamp(panStart.y + (pos.y - dragStart.y), state.lower.radius, canvas.height - state.lower.radius);
    }
    draw();
  } 
  else if (interactionMode === 'panImage' && activeElement === 'upper') {
    const deltaX = pos.x - dragStart.x;
    const deltaY = pos.y - dragStart.y;
    state.upper.imgOffsetX = panStart.x + deltaX;
    state.upper.imgOffsetY = panStart.y + deltaY;
    draw();
  }
  else if (interactionMode === 'moveText' && activeElement === 'text') {
    state.text.x = clamp(panStart.x + (pos.x - dragStart.x), 0, canvas.width);
    state.text.y = clamp(panStart.y + (pos.y - dragStart.y), 0, canvas.height);
    draw();
  }
}

function handleEnd(e) {
  if (activeElement) {
    e.preventDefault();
  }
  activeElement = null;
  interactionMode = 'none';
  dragStart = null;
  panStart = null;
  lastTouches = [];
}

/* Hilfsfunktion für Hintergrundbild-Dimensionen */
function getBackgroundDimensions() {
  if (!state.bgImg) return null;
  
  const imgAspect = state.bgImg.width / state.bgImg.height;
  const canvasAspect = canvas.width / canvas.height;
  
  let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
  
  if (imgAspect > canvasAspect) {
    drawHeight = canvas.height;
    drawWidth = drawHeight * imgAspect;
    offsetX = (canvas.width - drawWidth) / 2;
  } else {
    drawWidth = canvas.width;
    drawHeight = drawWidth / imgAspect;
    offsetY = (canvas.height - drawHeight) / 2;
  }
  
  return { drawWidth, drawHeight, offsetX, offsetY };
}

/* Drawing */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Hintergrund
  let bgDimensions = null;
  if (state.bgImg) {
    bgDimensions = getBackgroundDimensions();
    ctx.drawImage(state.bgImg, bgDimensions.offsetX, bgDimensions.offsetY, bgDimensions.drawWidth, bgDimensions.drawHeight);
  } else {
    ctx.fillStyle = "#e0e0e8";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  
  // Verbindungslinie
  const dist = distance(state.upper, state.lower);
  if (dist > state.upper.radius + state.lower.radius) {
    const angle = Math.atan2(state.lower.y - state.upper.y, state.lower.x - state.upper.x);
    const startX = state.upper.x + Math.cos(angle) * state.upper.radius;
    const startY = state.upper.y + Math.sin(angle) * state.upper.radius;
    const endX = state.lower.x - Math.cos(angle) * state.lower.radius;
    const endY = state.lower.y - Math.sin(angle) * state.lower.radius;
    
    ctx.save();
    // Harter Schatten: Schwarz, keine Transparenz, kein Blur
    ctx.shadowColor = "#000000";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 5;
    ctx.shadowOffsetY = 5;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    ctx.restore();
  }
  
  // Unterer Kreis
  drawCircleOutline(state.lower.x, state.lower.y, state.lower.radius);
  
  // Oberer Kreis
  drawCircleFilled(state.upper.x, state.upper.y, state.upper.radius, "#ffffff");
  
  // Oberer Kreis Inhalt
  if (state.overlayImg) {
    ctx.save();
    
    ctx.beginPath();
    ctx.arc(state.upper.x, state.upper.y, state.upper.radius - 4, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    
    ctx.translate(state.upper.x, state.upper.y);
    ctx.rotate(state.upper.rotation * Math.PI / 180);
    ctx.translate(-state.upper.x, -state.upper.y);
    
    const imgAspect = state.overlayImg.width / state.overlayImg.height;
    const circleSize = (state.upper.radius - 4) * 2;
    
    let drawWidth, drawHeight;
    
    if (imgAspect > 1) {
      drawHeight = circleSize * state.upper.zoom;
      drawWidth = drawHeight * imgAspect;
    } else {
      drawWidth = circleSize * state.upper.zoom;
      drawHeight = drawWidth / imgAspect;
    }
    
    const minSize = circleSize * state.upper.zoom;
    if (drawWidth < minSize) {
      drawWidth = minSize;
      drawHeight = drawWidth / imgAspect;
    }
    if (drawHeight < minSize) {
      drawHeight = minSize;
      drawWidth = drawHeight * imgAspect;
    }
    
    ctx.drawImage(
      state.overlayImg,
      state.upper.x - drawWidth/2 + state.upper.imgOffsetX,
      state.upper.y - drawHeight/2 + state.upper.imgOffsetY,
      drawWidth,
      drawHeight
    );
    
    ctx.restore();
    
  } else if (state.bgImg && bgDimensions) {
    ctx.save();
    
    ctx.beginPath();
    ctx.arc(state.upper.x, state.upper.y, state.upper.radius - 4, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    
    const lowerCircleSourceX = state.lower.x - bgDimensions.offsetX;
    const lowerCircleSourceY = state.lower.y - bgDimensions.offsetY;
    
    const scaleX = state.bgImg.width / bgDimensions.drawWidth;
    const scaleY = state.bgImg.height / bgDimensions.drawHeight;
    
    const srcCenterX = lowerCircleSourceX * scaleX;
    const srcCenterY = lowerCircleSourceY * scaleY;
    const srcSize = (state.lower.radius * 2 / state.upper.zoom) * scaleX;
    
    const srcX = srcCenterX - srcSize / 2;
    const srcY = srcCenterY - srcSize / 2;
    
    const upperCircleSize = (state.upper.radius - 4) * 2;
    ctx.drawImage(
      state.bgImg,
      srcX, srcY, srcSize, srcSize,
      state.upper.x - upperCircleSize/2, state.upper.y - upperCircleSize/2,
      upperCircleSize, upperCircleSize
    );
    
    ctx.restore();
  }
  
  // Outline für oberen Kreis
  drawCircleOutline(state.upper.x, state.upper.y, state.upper.radius);
  
  // Text zeichnen mit dynamischen Größen
  if (state.text.content && state.text.lines.length > 0) {
    const lineData = calculateLineData();
    
    ctx.save();
    ctx.translate(state.text.x, state.text.y);
    ctx.rotate(state.text.rotation * Math.PI / 180);
    
    // Berechne Gesamthöhe
    let totalHeight = 0;
    for (let data of lineData) {
      totalHeight += data.totalLineHeight;
    }
    
    let currentY = -totalHeight / 2;
    
    for (let i = 0; i < lineData.length; i++) {
      const data = lineData[i];
      const textY = currentY + data.fontSize * state.text.lineHeight / 2;
      
      // Wenn Zeile markiert oder längste Zeile: Farbiger Balken mit schwarzem Text
      if (data.isLongestWord) {
        // Balken mit hartem Schatten - oben iPadding/2, unten iPadding/4
        ctx.shadowColor = "#000000";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 3;
        ctx.shadowOffsetY = 3;
        
        const topPadding = data.iPadding / 2;
        const bottomPadding = data.iPadding / 4;
        const barHeight = data.fontSize + topPadding + bottomPadding;
        ctx.fillStyle = state.text.color;
        ctx.fillRect(
          -state.text.boxWidth / 2,
          textY - data.fontSize / 2 - topPadding,
          state.text.boxWidth,
          barHeight
        );
        
        // Schatten zurücksetzen für Text
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        
        // Text schwarz
        ctx.font = `${data.fontWeight} ${data.fontSize}px 'Roboto', sans-serif`;
        ctx.fillStyle = '#000000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(data.text, 0, textY);
        
      } else {
        // Normaler Text mit hartem Schatten
        ctx.font = `${data.fontWeight} ${data.fontSize}px 'Roboto', sans-serif`;
        ctx.fillStyle = state.text.color;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        
        ctx.shadowColor = "#000000";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 3;
        ctx.shadowOffsetY = 3;
        
        // Text beginnt am linken Rand der Textbox
        const textX = -state.text.boxWidth / 2;
        
        ctx.fillText(data.text, textX, textY);
        
        // Unterstrich mit Schatten - NICHT bei Stern-Zeilen und NICHT bei letzter Zeile
        if (i < lineData.length - 1) {
          const underlineY = textY + data.fontSize * 0.5 - data.underlineThickness / 2;
          
          ctx.fillRect(
            -state.text.boxWidth / 2,
            underlineY,
            state.text.boxWidth,
            data.underlineThickness
          );
        }
      }
      
         // Wasserzeichen in der letzten Zeile
      if (data.isLastLine && state.watermarkImg) {
        ctx.save();
        
        // Wasserzeichen: 90% der Schriftgröße, am rechten Rand der Textbox
        const wmSize = data.fontSize * 0.9;
        const wmX = state.text.boxWidth / 2 - (wmSize / 2);
        const wmY = textY - (data.fontSize * 0.05);
        
        // Schatten ausschalten vor dem Zeichnen
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Wasserzeichen ohne Schatten
        ctx.drawImage(state.watermarkImg, wmX - wmSize / 2, wmY - wmSize / 2, wmSize, wmSize);
        
        ctx.restore();
      }
      
      currentY += data.totalLineHeight;
    }
    
    ctx.restore();
  }
}

function drawCircleFilled(x, y, radius, fillColor) {
  ctx.save();
  ctx.fillStyle = fillColor;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawCircleOutline(x, y, radius) {
  ctx.save();
  // Harter Schatten
  ctx.shadowColor = "#000000";
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 5;
  ctx.shadowOffsetY = 5;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

/* Initial Draw */
draw();
  </script>
</body>
</html>
